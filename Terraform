#########################
Day 27 : 25th August 2025
#########################	

- Before terraform we relied on aws console/ AWS cli commands to provision the resources
- Managing shell script is bit difficult as we have to validate each every module as there is no predifined resources
- Now we have options as terraform converting into declearative scripts from shell scripts
- Terraform declearative language which uses harschi corop language which will be json file format
- Any terraform file extension should be saved as .tf
- Instead of terraform you can also use cloudformation 

Types of IAC Tools
- Configuration Managment
   - Ansible
   - Puppet
   - saltstack
- Server Templating
   - docker
   - packer
   - vagrant
- Provisioning tools
   - Terraform
   - CouldFormation


	- Infra-Structure Provisioning using Terraform ::::
	
		
		Dev Environments 
		
		Test Environments 
		
		
	- IAC Tool : Terraform 	
		
		- Terraform Process Workflow 
		
		- Working with Terraform 
		
			- Install Terraform in Local Machine
		
		- Terraform Process Workflow :::
		
			- Identify the Scope of Target Environment (AWS/Azure/GCP)
			
			- Write Terraform Scripts based on the Scope 
			
			- Perform Terraform Init --> Initialize Terraform Provider to the Terraform Project 
			
			- Perform Terraform Plan --> To Preview the Terraform Script
			
			- Perform Terraform Apply -> To apply the changes to target Infra-Structure
			
	
	- Working with Terraform :::
		
		- About Terraform Registry/Provider 
		
				https://registry.terraform.io/browse/providers
				
				
resource "aws_instance" "example" {
  ami           = "resolve:ssm:/aws/service/ami-amazon-linux-latest/al2023-ami-kernel-default-x86_64"
  instance_type = "t3.micro"

  tags = {
    Name = "HelloWorld"
  }
}



		- Installation & Configuration of Terraform in Local Machine
			
				https://developer.hashicorp.com/terraform/tutorials/aws-get-started/install-cli
				
	Working with Terraform :::
	
		- Install Terraform 		--> Local Windows Machine / Linux Machine 
		
				https://developer.hashicorp.com/terraform/tutorials/aws-get-started/install-cli
				
				https://developer.hashicorp.com/terraform/install
				

				Using Manual Approach - Install Terraform on local windows machine 
				
					https://developer.hashicorp.com/terraform/install
				
					- Download Windows AMD64 Version Terraform -- zipfile 
						- Right Click and Extract all 
							- Get the Extracted Terraform Folder 
								- Get the terraform - binary file 
								
					- Setup Environment Variable for terraform binary file 
						- from windows start menu, search for enviroment variable 
							- click of edit enviroment variable setting 
								- find system properties dialog 
									- select enviroment variables button
										- On Environment Variables Dialog 
											- goto to System Variable 
												- Select path variable and edit 
													- Click on New 
														- add C:\Softwares\terraform_1.7.2_windows_amd64
															- apply the changes and close the settings
				
				
		- Install Visual Studio Code 	- IDE used to create Terraform Projects 
			
				https://code.visualstudio.com/download
				
		
		- Open Visual Studio Code - Create Terraform Project 


#########################
Day 28 : 26th August 2025
#########################	

		- Install Visual Studio Code 	- IDE used to create Terraform Projects 
			
				https://code.visualstudio.com/download
				
		
		- Open Visual Studio Code 
		
		- Install the Extension/Plugins :
		
			Terraform Extension for Visual Studio Code
		
		- Create Terraform Project :::
		
		
			- Goto File Menu - Open Folder 
		
		
			- Goto Terminal Menu and Open New Terminal 
			
				terraform --version
				
				
		
		
		
		
		Requirement :
		
			- Create AWS Resources(EC2 Instances) using Terraform :
			
				- Authentication?
				
				- Create aws access key and secret key using AWS Security Crential Page.
				
					Accesskey: sdsdf4
					
					SecretKey: qsadfs
					

    provider "aws" {
    region ="ap-south-1"
    access_key = "dfasdfFKJDHF"
    secret_key = "adsfhadkflhalkdfhaklsd"
    }


      resource "aws_instance" "example" {
         ami           = "resolve:ssm:/aws/service/ami-amazon-linux-latest/al2023-ami-kernel-default-x86_64"
         instance_type = "t3.micro"

         tags = {
          Name = "HelloWorld"
          }
      }

		- Terraform Process Workflow :::
		
			- Identify the Scope of Target Environment (AWS/Azure/GCP)
			
			- Write Terraform Scripts based on the Scope 
			
			- Perform Terraform Init --> Initialize Terraform Provider to the Terraform Project 
			
			- Perform Terraform Plan --> To Preview the Terraform Script
			
			- Perform Terraform Apply -> To apply the changes to target Infra-Structure
			
			
		- Using Terraform :::
		
			- Create/Add resources 					====> 		'+'
			
			- Destroy/Delete Resources 				====>		'-'
			
			- Update/Alter Resources 				====> 		'~'
			
			
	
		- Terraform State file- :
			
			terraform:tfstate 		
			
			
			
			terraform init 
			
			terraform plan 
			
			terraform apply
			
			terraform apply -auto-approve
			
			terraform destroy
			
			terraform destroy -auto-approve
			


Demo2: We will deploy a project with below resources
EC2 instance- security group- subnet- vpc- routetable- Internetgatewauy

- File menu
- click on open folder
- pl-tf-project2
- 
Provider:

    provider "aws" {
    region ="ap-south-1"
    access_key = "dfasdfFKJDHF"
    secret_key = "adsfhadkflhalkdfhaklsd"
    }


Create VPC

resource "aws_vpc" "main" {
  cidr_block       = "10.0.0.0/16"
  instance_tenancy = "default"

  tags = {
    Name = "main"
  }
}


Create subnet

resource "aws_subnet" "main" {
  vpc_id     = aws_vpc.main.id_address =true
  subnet_id aws_subnet.mysubnet9.id
  vpc_security_group_ids =[aws_security_group.mysg9.id]
  key_name = "aws2025-keypair1"

  tags = {
    Name = "Main"
  }
}

InternetGateway

resource "aws_internet_gateway" "gw" {
  vpc_id = aws_vpc.main.id

  tags = {
    Name = "main"
  }
}


Routetable

resource "aws_route_table" "example" {
  vpc_id = aws_vpc.example.id

  route {
    cidr_block = "10.0.1.0/24"
    gateway_id = aws_internet_gateway.example.id
  }

  route {
    ipv6_cidr_block        = "::/0"
    egress_only_gateway_id = aws_egress_only_internet_gateway.example.id
  }

  tags = {
    Name = "example"
  }
}

Routable association

resource "aws_route_table_association" "a" {
  subnet_id      = aws_subnet.foo.id
  route_table_id = aws_route_table.bar.id
}


security grops
resource "aws_vpc" "mainvpc" {
  cidr_block = "10.1.0.0/16"
}

resource "aws_default_security_group" "default" {
  vpc_id = aws_vpc.mainvpc.id

  ingress {
    protocol  = -1
    self      = true
    from_port = 0
    to_port   = 0
  }

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }
}

      resource "aws_instance" "example" {
         ami           = "resolve:ssm:/aws/service/ami-amazon-linux-latest/al2023-ami-kernel-default-x86_64"
         instance_type = "t2.micro"
         associate_public_ip_address =true
         subnet_id = aws_subnet.
         tags = {
          Name = "HelloWorld"
          }
      }

	DevOps ::::
	
		CICD Pipeline:
		
		Scenario1 :
		
			Pipeline1 :
			
			- SCM-Checkout --> Build --> Deployed to Test Server 
			

		Scenario2 :

			Pipeline1 :
			Source_Code Repo :
			
			- SCM-Checkout --> Create New_Test_Server(Terraform) --> Configure New_Test_Server(Ansible)


			
			Pipeline2 :
			Source_Code Repo :
			- SCM-Checkout --> Build --> Deployed to New_Test_Server

			
		Scenario3 :
		
			Source_Code Repo :
			
				Application Source Code 
				
				Terraform Scripts 
				
				Ansible Playbooks 
				
				
			Pipeline1:
			
				SCM-Checkout --> Application_Build --> Create New_Test_Server(Terraform) --> Configure New_Test_Server(Ansible)
				
																												|
																												|
																												|
																						
																						  Deploy the changes to New_Test_Server
																						  
																						  
																												|
																												|
																												|
																												
																										Automated Testing 
																										
																												|
																												|
																												|
																												
																										Notify the User  
																										
																										Delete the New_Test_Server using Terraform Destroy 

																												|
																												|
																												|
																												
																											Deploy to Prod				
				
				
				
			
			
Next :::

	Continuous Monitoring using Prometheus/Grafana :::
