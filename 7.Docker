########################
Day 17 : 5th August 2025
########################

	- Docker Module ::
	
	- Containerization :
	
		- It is a process of packaging the applications along with its dependencies.
		
	- Virtual Machine :::
	
		- VM is called as a Hardware Level Virtualization 
		- VMs are create using Hyervisor
		- VMs are used to execute Operating System 
		- VMs will be up and running even if there is not active application/task
		- VMs consume more space and time to start-up the service.
	
	- Container :::

		- Container is called as a OS Level Virtualization 
		- Containers are create using Container Engine 
		- Containers are used to execute Application/Task, NOT Operating System
		- Containers will immediately go to exit state if there is no active Application/Task
		- Containers consume less space and time to start-up the service.	
		
		- Container uses the core properties of underlying Operating System
			- Core of OS - Kernel 			
				- Namespaces 
				- Control Groups 
				
			- Container run it is own isolate address space
			
		- Containers can reduce the no. of VMs 
			- We cannot completely elimate VM.
			
	
	- Terminologies ::
	
		- Container Engine 		
					# It is used to create and manage the Container Images and Containers
		
		- Container Image		
					# Container Image is a static file, the defines the properties of application and its dependencies
					# Container Image composed of various layers created using Dockerfile Instructions
					# Container Images are Non-Executable
					
		- Container	
					# Containers are the Executable units of Container Images.					
		
		- Container Registry:
					# Container Registry is used to maintain/Version Control the Container Images 
					# DockerHub is a default Container Registry for Docker Container Engine 
					https://hub.docker.com/
					
					
					Source Code Repo			Artifactory Library 				Container Registry

					github						jfrog/azArtifacts					DockerHub/ACR/ECR
								
					webapp.java_v1.0	==>		webapp.war_snapshot_V1.0	==> 	webapp_img:v1.0
					webapp.java_v1.1	==>		webapp.war_snapshot_V1.1	==>		webapp_img:v1.1
					
		- Container Repositories :
					# Container Repositories are the subset of Container Registry
			
	- Containerization :
	
		- It is a process of packaging the applications along with its dependencies.		

		
	Working with Containers :
	
	
	- Infra-Structure Perspective ::
		
		- Here, Using Container we can reduce the no. of VMs 
		- This we we can reduce the Infra-Structure Cost

		Jenkins_Master (VM)				
											==> Install Git, JDK, Jenkins											
										
			Jenkins_SlaveNode1 (VM1)		==> Java Build Tools					
			Jenkins_SlaveNode1 (VM1.1)		==> Java Build 						
			Jenkins_SlaveNode1 (VM2)		==> Python
			Jenkins_SlaveNode1 (VM3)		==> .Net
			Jenkins_SlaveNode1 (VM4)		==> Angular/Nodejs
			Jenkins_SlaveNode1 (VM5)		==> Ruby
				
		Using Docker :
		
		Jenkins_Master (VM)				
			Jenkins_Build_Server_Node (VM1)
				- Install Container Engine
						Create 	C1			==> Java Build Tools	
								C2          ==> Java Build 		
								C3          ==> Python
								C4          ==> .Net
								C5          ==> Angular/Nodejs
								C6          ==> Ruby
	
	
	- Developers/Deployment Perspective ::

	- Containerization :
	
		- It is a process of packaging the applications along with its dependencies.
		
		Role of Developers :
		
			In Dev Environment :
			
				Create Source Code 
				
				Create Artifacts				mywebapp.war 
					- jdk17, tomcat:8.0

				Unit Testing 
				
					Package the Application : (mywebapp.war,jdk17,tomcat:8.0)	==> Create Application Image : mywebappimg:v1.0
					
					Publish the Image - mywebappimg:v1.0 to Container Registry
				
				Promote the artifacts to Test Environments
				
			
			QA 			
				- pull the Application Image : mywebappimg:v1.0 from Container Registry
				- Create Container out of it.

				
			UAT	
				- pull the Application Image : mywebappimg:v1.0 from Container Registry
				- Create Container out of it. 


			PROD 
				- pull the Application Image : mywebappimg:v1.0 from Container Registry
				- Create Container out of it. 
							
							
							
Next ::

	Working with Docker :
	
		- Install Docker Container Engine 
		- Docker Cli Commands 
	


########################
Day 18 : 7th August 2025
########################	
	
	Working with Docker :
	
		- Install Docker Container Engine 
		- Docker Cli Commands 			
		
	Installation of Container Engine :
	
		apt install docker.io -y			# Install Docker Container Engine in Jenkins Slave-Node/Build Server
	
	Docker Cli Commands :	
	
		docker --version
		
		docker images				# List the Images  
		
		docker ps 					# List the Active/running Containers
		
		docker ps -a 				# List all the Container (Active & In-Active)		
		
		Login to DockerHub Console :
		
		Explore the Images!
		
		
		docker pull <image_name>		# To download a latest version of Container Image from DockerHub to Local Machine 
		
		docker pull <image_name>:<tag>	# To download a specific version of Container Image from DockerHub to Local Machine 
		
		docker run <image_name>			# To create a Container based on Container Image 
		
		
		
		Three Modes of Container Execution :
		
		- Foreground/Attached Mode :
		
			docker run <image_name> 
			
			Eg.:
			
				docker run ubuntu sleep 20
		
		- Background/Detached Mode :
		
			docker run -d <image_name> 
			
			Eg.: 
			
				docker run -d ubuntu sleep 20
		
		- Interactive Mode :
		
			docker run -it <image_name>
			
			Eg.: 
			
				docker run -it ubuntu bash
				
				exit							# Exit/stop the Container  
		
		- docker start <Container_ID> 			# Start the Container
		
		- Login to Running Container :
		
			docker exec -it <Container_ID> bash 
			
			Eg.:
			
			docker exec -it 092dc9986518 bash
		
			exit 								# Log-off from the Container 
			
		- docker stop <Container_ID> 			# Stop the Running Container 
		
		
		- Port Mapping/Port Binding :::
		
			- It is used to expose the Container Application to Internet.			
			
			docker run -it -p 8085:8080 tomcat:8.0 			
		
				-p <host_port>:<container_port>
			
				Access the Application running inside the container using port mapping :
			
				<external_ip_addr>:<host_port>
				
				43.204.233.96:8085
				
		
		- Remove Containers & Images from Local Machine!
		
			- docker rmi <image_name>			# To Remove Container Images 
			
			- docker rm <Container_ID>			# To Remove Containers 
				
				
		- Docker Volume ::::
		
			- Container are basically used to execute application/task.			
			- Containers are actually used to run the stateless application.
			
			- This is to maintain pesistant data!
			
		3-Tier Application Architecture ????
		
			Sign_in Micro-Service
			
				- Front-End Layer	==> User Interaction 	=> C1 
				
				- Application Layer	==> Business Logic		=> C2 
				
				- Back-End Layer	==> Database 			=> C3 
		
		
Next : 
			Work with Containers 
			Build Images 
			Container Orchestration Tools & Concepts
