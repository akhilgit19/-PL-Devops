########################
Day 17 : 5th August 2025
########################

	- Docker Module ::
	
	- Containerization :
	
		- It is a process of packaging the applications along with its dependencies.
		
	- Virtual Machine :::
	
		- VM is called as a Hardware Level Virtualization 
		- VMs are create using Hyervisor
		- VMs are used to execute Operating System 
		- VMs will be up and running even if there is not active application/task
		- VMs consume more space and time to start-up the service.
	
	- Container :::

		- Container is called as a OS Level Virtualization 
		- Containers are create using Container Engine 
		- Containers are used to execute Application/Task, NOT Operating System
		- Containers will immediately go to exit state if there is no active Application/Task
		- Containers consume less space and time to start-up the service.	
		
		- Container uses the core properties of underlying Operating System
			- Core of OS - Kernel 			
				- Namespaces 
				- Control Groups 
				
			- Container run it is own isolate address space
			
		- Containers can reduce the no. of VMs 
			- We cannot completely elimate VM.
			
	
	- Terminologies ::
	
		- Container Engine 		
					# It is used to create and manage the Container Images and Containers
		
		- Container Image		
					# Container Image is a static file, the defines the properties of application and its dependencies
					# Container Image composed of various layers created using Dockerfile Instructions
					# Container Images are Non-Executable
					
		- Container	
					# Containers are the Executable units of Container Images.					
		
		- Container Registry:
					# Container Registry is used to maintain/Version Control the Container Images 
					# DockerHub is a default Container Registry for Docker Container Engine 
					https://hub.docker.com/
					
					
					Source Code Repo			Artifactory Library 				Container Registry

					github						jfrog/azArtifacts					DockerHub/ACR/ECR
								
					webapp.java_v1.0	==>		webapp.war_snapshot_V1.0	==> 	webapp_img:v1.0
					webapp.java_v1.1	==>		webapp.war_snapshot_V1.1	==>		webapp_img:v1.1
					
		- Container Repositories :
					# Container Repositories are the subset of Container Registry
			
	- Containerization :
	
		- It is a process of packaging the applications along with its dependencies.		

		
	Working with Containers :
	
	
	- Infra-Structure Perspective ::
		
		- Here, Using Container we can reduce the no. of VMs 
		- This we we can reduce the Infra-Structure Cost

		Jenkins_Master (VM)				
											==> Install Git, JDK, Jenkins											
										
			Jenkins_SlaveNode1 (VM1)		==> Java Build Tools					
			Jenkins_SlaveNode1 (VM1.1)		==> Java Build 						
			Jenkins_SlaveNode1 (VM2)		==> Python
			Jenkins_SlaveNode1 (VM3)		==> .Net
			Jenkins_SlaveNode1 (VM4)		==> Angular/Nodejs
			Jenkins_SlaveNode1 (VM5)		==> Ruby
				
		Using Docker :
		
		Jenkins_Master (VM)				
			Jenkins_Build_Server_Node (VM1)
				- Install Container Engine
						Create 	C1			==> Java Build Tools	
								C2          ==> Java Build 		
								C3          ==> Python
								C4          ==> .Net
								C5          ==> Angular/Nodejs
								C6          ==> Ruby
	
	
	- Developers/Deployment Perspective ::

	- Containerization :
	
		- It is a process of packaging the applications along with its dependencies.
		
		Role of Developers :
		
			In Dev Environment :
			
				Create Source Code 
				
				Create Artifacts				mywebapp.war 
					- jdk17, tomcat:8.0

				Unit Testing 
				
					Package the Application : (mywebapp.war,jdk17,tomcat:8.0)	==> Create Application Image : mywebappimg:v1.0
					
					Publish the Image - mywebappimg:v1.0 to Container Registry
				
				Promote the artifacts to Test Environments
				
			
			QA 			
				- pull the Application Image : mywebappimg:v1.0 from Container Registry
				- Create Container out of it.

				
			UAT	
				- pull the Application Image : mywebappimg:v1.0 from Container Registry
				- Create Container out of it. 


			PROD 
				- pull the Application Image : mywebappimg:v1.0 from Container Registry
				- Create Container out of it. 
							
							
							
Next ::

	Working with Docker :
	
		- Install Docker Container Engine 
		- Docker Cli Commands 
	


########################
Day 18 : 7th August 2025
########################	


- Login to slave node
- sudo -i 
	Working with Docker :
	
		- Install Docker Container Engine 
		- Docker Cli Commands 			

-	Installation of Container Engine :
	
		apt install docker.io -y			# Install Docker Container Engine in Jenkins Slave-Node/Build Server
	
	Docker Cli Commands :	
	
		docker --version
		
		docker images				# List the Images  
		
		docker ps 					# List the Active/running Containers
		
		docker ps -a 				# List all the Container (Active & In-Active)		
		
		Login to DockerHub Console :
		
		Explore the Images!

- If you want to work with any image, click on the tags
		
		docker pull <image_name>		# To download a latest version of Container Image from DockerHub to Local Machine 
		
		docker pull <image_name>:<tag>	# To download a specific version of Container Image from DockerHub to Local Machine 
		
		docker run <image_name>			# To create a Container based on Container Image 
		
- docker pull ubuntu 
- if you say docker images, you can see the image and image ID size,

- creating container- docker run  ubuntu 
- docker ps (show the running container)
- docker ps -a(show all the containers)
- docker run ubuntu sleep 30


 
		Three Modes of Container Execution :
		
		- Foreground/Attached Mode :
		
			docker run <image_name> 
			
			Eg.:
			
				docker run ubuntu sleep 20
		
		- Background/Detached Mode :
		
			docker run -d <image_name> 
			
			Eg.: 
			
				docker run -d ubuntu sleep 20
		
		- Interactive Mode :
		
			docker run -it <image_name>
			
			Eg.: 
			
				docker run -it ubuntu bash
				
				exit							# Exit/stop the Container  
		
		- docker start <Container_ID> 			# Start the Container
		
		- Login to Running Container :
		
			docker exec -it <Container_ID> bash 
			
			Eg.:
			
			docker exec -it 092dc9986518 bash
		
			exit 								# Log-off from the Container 
			
		- docker stop <Container_ID> 			# Stop the Running Container 
		



- docker run alpine




		- Port Mapping/Port Binding :::
		
			- It is used to expose the Container Application to Internet.			
			
			docker run -it -p 8085:8080 tomcat:8.0 			
		
				-p <host_port>:<container_port>
			
				Access the Application running inside the container using port mapping :
			
				<external_ip_addr>:<host_port>
				
				43.204.233.96:8085
				
		
		- Remove Containers & Images from Local Machine!
		
			- docker rmi <image_name>			# To Remove Container Images 
			
			- docker rm <Container_ID>			# To Remove Containers 
				
				
		- Docker Volume ::::
		
			- Container are basically used to execute application/task.			
			- Containers are actually used to run the stateless application.
			
			- This is to maintain pesistant data!
			
		3-Tier Application Architecture ????
		
			Sign_in Micro-Service
			
				- Front-End Layer	==> User Interaction 	=> C1 
				
				- Application Layer	==> Business Logic		=> C2 
				
				- Back-End Layer	==> Database 			=> C3 
		
		
Next : 
			Work with Containers 
			Build Images 
			Container Orchestration Tools & Concepts


########################
Day 19 : 8th August 2025
########################		
	
	Docker Volumes :::
	
		- Docker Volume ::::
		
			- Container are basically used to execute application/task.			
			- Containers are actually used to run the stateless application.
			
			- This is to maintain pesistant data!	
			
		Stateless application :
		
			- Application that never retain the state of execution 
		
		Stateful application :
		
			- To work with the stateful applications, Docker Volumes can be used.
			
			
		docker volume list 					# List the Docker Volumes 
		
		docker volume create pl-vol1		# Create a docker volume 
		
		docker volume inspect pl-vol1		# Inpect/Get the Properties of Volume
		
		docker run -it --mount source=pl-vol1,destination=/pl-vol1 ubuntu bash  

- Start the slavenode 
- login to slave node VM
- docker ps ( show the running containers
- docker images 
- docker run -it ubuntu bash ( it creates ubuntu container in interactive mode)
- root@5c26dcb5acd4:/# ls
bin bood dev etc home lib lib64 media mnt opti pro root 
- root@5c26dcb5acd4:/# exit
exit
- root@ip-172-31-3-184:# docker volume list
- create a new volume
- docker volume create pl-vol1
- if you list now you can see the volume
	root@ip-172-31-3-184:# docker volume ist
 DRIVER    VOLUME NAME
local       pl-vol1
- docker volume inspect pl-vol1
[
   {
         "createdAt" "2025-08-08T14:46:36Z",
         "Driver": "local",
         "Labels": null,
         "Mountpoint": "/var/lib/docker/volumes/pl-vol1/_data",
         "Name": "pl-vol1",
         "Options": null,
         "Scope": "local"
    }
]

- cd /var/lib/docker/volumes/
- ls
- you can see pl-vol1
- cd pl-vol1
- cd _data
- here is the persistent data will be store
- docker run -it --mount source=pl-vol1,destination=/pl-vol1 ubuntu bash  
- ls 
-  you will see the volume 
bin boot dev etc home lib lib64 media mnt optio pl-vol1 proc root run sbin srv sys  tmp usr var
- cd pl-vol1/
- pwd
/pl-vol1
- root@21330000984d76: /pl-vol1# echo "rec1" >> outfile.txt
- root@21330000984d76: /pl-vol1# ls
outfile.txt
- root@21330000984d76: /pl-vol1# exit
exit
- Now if you give docker ps, no container is upon running
- docker ps -a (you will the container in exit state
- if u give ls command you can see the file
- pwd
/var/lib/docker/volumes/pl-vol1/_data"
-root@ip-172-31-3-184:/var/lib/docker/volumes/pl-vol1/_data # cat outfile.txt
rec1
-root@ip-172-31-3-184:/var/lib/docker/volumes/pl-vol1/_data # echo "rec1" >> infile1.txt
- ls
infile1.txt outfile.txt
-root@ip-172-31-3-184:/var/lib/docker/volumes/pl-vol1/_data # docker run -it --mount source=pl-vol1,destination=/pl-vol1 ubuntu bash
-root@ip-172-31-3-184:/# ls
bin boot dev etc home lib lib64 media mnt optio pl-vol1 proc root run sbin srv sys  tmp usr var
-root@ip-172-31-3-184:# cd pl-vol1
-root@ip-172-31-3-184:/pl-vol1# ks
infile1.txt outfile.txt
-root@ip-172-31-3-184:/pl-vol1#
- if i want 500TB in the main storage VM it cannot be possible 
  so docker volume cannot be attached to container vlevel it should be attached to sservice level like EBS etc




	Create Container Images :::
	
	- docker commit :::
		
		=> To Create a New Container Image based on the properties of existing Container.
		
			Syntax :

				docker commit <existing_container_id> <dockerhub_repo_name>/New_Image_Name>:<tag_Name>
				
				docker commit 83d261074037 loksaieta/pl-mvn-env-img:v1.0

				
	- docker build :::
	
		- To create a new Container Image based on the Dockerfile reference.
		- Dockerfile composed of Instructions to Create Docker Container Images
		- Application Developers create the Dockerfile and update in the Source Code Repository. 
		
			Syntax :
			
			docker build -t <dockerhub_repo_name>/New_Image_Name>:<tag_Name> .		# '.' refers to the Dockerfile path
			
			docker build -t loksaieta/pl-mvn-env-img1 .
			
		vi Dockerfile 
		
			FROM ubuntu 
			RUN apt update -y 
			RUN apt install git -y 
			RUN apt install maven -y
			
			
	- docker push :::
	
		- To Publish the Image to Remote DockerHub Repository.
		
		
		- Access Token : PAT 
		
		
			docker login -u loksaieta
		
			dcasdfsdsdfsdJY
			
			docker push loksaieta/pl-mvn-env-img1
			
			docker push loksaieta/pl-mvn-env-img:v1.0



Creating build container in Slave Machine:
- In my slave machine, creating a build docker container
- docker ps -a
- docker run -it ubuntu bash
- it will create one new container 
- you will be inside the container and give this ls command
bin boot dev etc home lib lib64 media mnt  opt proc root run sbin srv sys tmp usr var
- git --version (you will not found)
- apt update -y (update the default packages)
- apt install git -y
- git --version
- apt install maven -y
- mvn --version
- if i exit  give exit
exit
- and to start again
 docker ps
 docker start 83d26109888
 docker exec -it 83d26109888 bash
- git -version


docker commit:
In the dockerhub, In my hub, click on repositories , click on create repository
- repository name

	docker commit <existing_container_id> <dockerhub_repo_name>/New_Image_Name>:<tag_Name>
				
	docker commit 83d261074037 loksaieta/pl-mvn-env-img:v1.0
above command create  anew image in local repo based on previous container 
- docker images
loksaieta/pl-mvn-env-img:v1.0
- docker run -it loksaieta/pl-mvn-env-img:v1.0 bash
- git --vesion


docker build:
- mkdir docker-contents
- cd docker-contents/
- docker-contents/ pwd
/root/docker-contents/
- vi Dockerfile
			FROM ubuntu 
			RUN apt update -y 
			RUN apt install git -y 
			RUN apt install maven -y
- you can run below commands			
Syntax :
			
docker build -t <dockerhub_repo_name>/New_Image_Name>:<tag_Name> .		# '.' refers to the Dockerfile path
			
docker build -t loksaieta/pl-mvn-env-img1 .

- docker images (you will see new image -loksaieta/pl-mvn-env-img


Docker push:
- click on profile in docker hub, click on account settings
- In the left side , click on personal access tokens
- click on generate new token
- token name pl-test-part1
- expiration datays -90 days
- access- read write delete
- click on generate

- once u run:  docker login -u loksaieta
- you will be asked for token give the generated token- dcasdfsdsdfsdJY.
-
	docker push loksaieta/pl-mvn-env-img1
	docker push loksaieta/pl-mvn-env-img:v1.0
- now if you go to repository you can see the image
- click on the image , you can see image layers

docker stop 83d26109888


Container Orchestration ::
	

		- Overview of Docker Compose :::
		
			- Used to execute multiple containers as a Service. 
			- The Container specification will be defined in a manifest file - written using *.yaml script.
			
			- Install and configure docker compose 
				https://docs.docker.com/compose/install/
				
				https://docs.docker.com/compose/install/linux/#install-the-plugin-manually
				

		3-Tier Application Architecture ????
		
			Sign_in Micro-Service		
			
				- Front-End Layer	==> User Interaction 	=> C1 
				
				- Application Layer	==> Business Logic		=> C2 
				
				- Back-End Layer	==> Database 			=> C3 


				- Front-End Layer	==> User Interaction 	=> C1.1,1.2,1.3 
				
				- Application Layer	==> Business Logic		=> C2.1,2.2,2.3
				
				- Back-End Layer	==> Database 			=> C3.1,3.2,3.3

		Work with Docker Compose ::
		
			Install Docker_Compose
			
			https://docs.docker.com/compose/install/linux/
			
# Manual Installation of Docker Compose :::
			
DOCKER_CONFIG=${DOCKER_CONFIG:-$HOME/.docker}
mkdir -p $DOCKER_CONFIG/cli-plugins
curl -SL https://github.com/docker/compose/releases/download/v2.24.0/docker-compose-linux-x86_64 -o $DOCKER_CONFIG/cli-plugins/docker-compose

chmod +x $DOCKER_CONFIG/cli-plugins/docker-compose
	
docker compose version

vi docker-compose.yaml



### Yaml Files are based on Keys & Values -- key:value Pairs

version: '3'
services:
  webserv1:
    image: "tomcat:8.0"
    ports:
      - 8098:8080
  dbserv1:
    image: "redis:alpine"
	
docker compose up 

docker compose down 

docker ps

				
		- Overview of Docker Swarm :::
		
			- Docker Swarm is one the Container Orchestration Tools.
			- It is meant only for Docker Containers.
			- Used to Ensure High Availability of Containers by creating Replicas of Containers.
			- We cannot Do Auto-Scaling or Load Balancing!
				
		- Kubernetes!
		
		Docker Container : 
		
		AWS :	ECS/ECR/EKS
		
		Azure : ACS/ACR/AKS
		
		GCP :	GCE/GCR/GKE

		- Kubernetes!
		
			- It is a Open-Source Container Orchestration Tool 
			- Kubernetes is used to Deploy any type of Containers.
			- It is used to ensure high availability of the Applications/services running thru Containers.
			- Used to Ensure High Availability of Containers by creating Replicas of Containers.
			- It supports Auto-Scaling & Load Balancing.		
			
			- App Config file - Manifest file - *.yaml / *.json


#########################
Day 20 : 11th August 2025
#########################		
		
	- Containerization :::
		
		- Docker Build Command to create any Container Image
		
		- Create Dockerfile & maintained in the Source Code Repository
		
	
	- Source Code Repo. URL 
	
	- Create a CICD Pipeline using Jenkins :
	
	- Servers & Tools :
		
		Jenkins_Master 			==> Create CICD Pipeline Projects and Schedule to run in the resp. Agents 
								==> git,jdk,jenkins 
								
			Jenkins_Build_Server_Node	==> Perform Application Build 
										==> git,jdk,maven,docker
	

	- Add devopsadmin user to docker group :
	
		usermod -aG docker devopsadmin


		
	- CICD Pipeline Stages :
	
		Input : 	Source Code Repo. URL 
		
		Output :	Application Artifacts, Application Container Image, Publish to Container Registry.
		
		
		Pipeline :

			- SCM-Checkout                        (using git)
			- Application_Build 			*.war (using maven)
			- Application_Image_Build              (using docker)
			- Publish Application_Image to Container Registry(using DockerHub)
			
		Dockerfile :

			FROM ubuntu 
			RUN apt update -y 
			RUN apt install git -y 
			RUN apt install maven -y
					
		
		FROM tomcat:8.0
		COPY ./target/*.war /usr/local/tomcat/webapps
		EXPOSE 8080		
		
		
		Dockerfile Instructions :
		
		FROM 			# This is identify the based Image 
		
		RUN				# To execute any package manager

		COPY 			# To Copy the files from host volume to container volume 
		
		CP				# To Copy the files within the Container Volume 
		
		ADD 			# To Copy/Download the files from external URLs to Container Volume 

		EXPOSE			# To set the Container Port.
		
		WORKDIR			# To Set the Current Working Directory
		
		CMD				# To Set the default Start-up Task to start a Container 
						# The Start-up Task can be Modified at the time of Container Creation 
						
		ENTRYPOINT		# To Set the default Start-up Task to start a Container 
						# The Start-up Task cannot be Modified at the time of Container Creation 						
		

- In Slave Node:c
- Login to your slave node machine.
- sudo -i
- docker images ( You can see all the images as a root user
- su -devopsadmin ( if you login as a devopsadmin user it will throw as errror while createting docker images)
- So whenver im communicating from master to slave i will user devopsadmin user
- So simple we have to add the devopsadmin user to docker group
- usermod -aG docker devopsadmin
- su - devopsadmin
- docker images( Now you will not get any permission error)

- cd workspace/PL-CICD_Pipeline_MavenProjects1
- ls
Dockerfile README.md mvnw mvnw.cmd pom.xml src target
- pwd
/home/devopsadmin/workspace/PL-CICD_Pipeline_MavenProjects1
- cat Dockerfile
		FROM tomcat:8.0
		COPY ./target/*.war /usr/local/tomcat/webapps
		EXPOSE 8080		

- docker  build -t <imagename> .
- exit , you will get into root user

- Restart the slave node give reboot command 


- Now go to manage jenkins, In security, credentials
- click on global and click on add credential
- kind - username and password
- id - dockerlogind
- description -dockerlogind
- username- loksaieta
- password - personal access docker token
- click on create


- From master node copy the ip adress and open in the browser
- open PL-CICD_Pipeline_MavenProjects1 job
- In trigggers  copy below pipeline and paste it

- CICD Pipeline using Docker:

	
pipeline {
    agent { label 'slave1' }

	environment {	
		DOCKERHUB_CREDENTIALS=credentials('dockerloginid')
	}

    stages {
        stage('SCM_Checkout') {
            steps {
                echo 'Perform SCM_Checkout from github repository'
				git 'https://github.com/PL-DevOps-GenAI-0625/java-webapp-project.git'
            }
        }
		
        stage('Application Build') {
            steps {
                echo 'Perform Maven Application Build'
                sh 'mvn clean package'
            }
        }
		
        stage('Build Docker Image') {
            steps {

				sh "docker build -t loksaieta/pl-javawebappimg ."
				
            }
        }
		
		stage('Login2DockerHub') {

			steps {
				sh 'echo $DOCKERHUB_CREDENTIALS_PSW | docker login -u $DOCKERHUB_CREDENTIALS_USR --password-stdin'
			}
		}
		
		stage('Publish_to_Docker_Registry') {
			steps {
				sh "docker push loksaieta/pl-javawebappimg"
			}
		}

    }
}


- click on build

- now in slave node
- sudo -i
- su - devopsadmin
- docker images
REPOSITORY                   TAG      IMAGE ID              CREATED               SIZE
loksaieta/pl-javawebappimg   latest   0022d38bb3f2           57 ago               420 MB

You can check now in slave node target container.

In slave
- sudo -i
- su -devopsadmin
- docker run -it loksaieta/pl-javawebappimg bash (running container via interactive mode)
root@3828ba7dfaa2:/user/local/tomcat# ls
LICENSE   NOTICE   RELEASE-NOTES   RUNNING.txt   bin   conf  include lib logs native-jni-lib   temp webapps work
-
root@3828ba7dfaa2:/user/local/tomcat# cd webapps/
- ls
- ROOT demo-1.0-SNAPSHOT.war docs examples host-manager  manager
-root@3828ba7dfaa2:/user/local/tomcatwebapps#

- Now i want to run the container as webservice
- docker run -t -p 8080:8080 loksaieta/pl-javawebappimg
- now it will start the tomcat service
- copy the slave node public ip curl http:/publicip:8080/demo-1.0-SNAPSHOT.war
- You will see the webpage






















