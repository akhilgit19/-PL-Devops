#########################
Day 27 : 25th August 2025
#########################	

- Before terraform we relied on aws console/ AWS cli commands to provision the resources
- Managing shell script is bit difficult as we have to validate each every module as there is no predifined resources
- Now we have options as terraform converting into declearative scripts from shell scripts
- Terraform declearative language which uses harschi corop language which will be json file format
- Any terraform file extension should be saved as .tf
- Instead of terraform you can also use cloudformation 

Types of IAC Tools
- Configuration Managment
   - Ansible
   - Puppet
   - saltstack
- Server Templating
   - docker
   - packer
   - vagrant
- Provisioning tools
   - Terraform
   - CouldFormation


	- Infra-Structure Provisioning using Terraform ::::
	
		
		Dev Environments 
		
		Test Environments 
		
		
	- IAC Tool : Terraform 	
		
		- Terraform Process Workflow 
		
		- Working with Terraform 
		
			- Install Terraform in Local Machine
		
		- Terraform Process Workflow :::
		
			- Identify the Scope of Target Environment (AWS/Azure/GCP)
			
			- Write Terraform Scripts based on the Scope 
			
			- Perform Terraform Init --> Initialize Terraform Provider to the Terraform Project 
			
			- Perform Terraform Plan --> To Preview the Terraform Script
			
			- Perform Terraform Apply -> To apply the changes to target Infra-Structure
			
	
	- Working with Terraform :::
		
		- About Terraform Registry/Provider 
		
				https://registry.terraform.io/browse/providers
				
				
resource "aws_instance" "example" {
  ami           = "resolve:ssm:/aws/service/ami-amazon-linux-latest/al2023-ami-kernel-default-x86_64"
  instance_type = "t3.micro"

  tags = {
    Name = "HelloWorld"
  }
}



		- Installation & Configuration of Terraform in Local Machine
			
				https://developer.hashicorp.com/terraform/tutorials/aws-get-started/install-cli
				
	Working with Terraform :::
	
		- Install Terraform 		--> Local Windows Machine / Linux Machine 
		
				https://developer.hashicorp.com/terraform/tutorials/aws-get-started/install-cli
				
				https://developer.hashicorp.com/terraform/install
				

				Using Manual Approach - Install Terraform on local windows machine 
				
					https://developer.hashicorp.com/terraform/install
				
					- Download Windows AMD64 Version Terraform -- zipfile 
						- Right Click and Extract all 
							- Get the Extracted Terraform Folder 
								- Get the terraform - binary file 
								
					- Setup Environment Variable for terraform binary file 
						- from windows start menu, search for enviroment variable 
							- click of edit enviroment variable setting 
								- find system properties dialog 
									- select enviroment variables button
										- On Environment Variables Dialog 
											- goto to System Variable 
												- Select path variable and edit 
													- Click on New 
														- add C:\Softwares\terraform_1.7.2_windows_amd64
															- apply the changes and close the settings
				
				
		- Install Visual Studio Code 	- IDE used to create Terraform Projects 
			
				https://code.visualstudio.com/download
				
		
		- Open Visual Studio Code - Create Terraform Project 


#########################
Day 28 : 26th August 2025
#########################	

		- Install Visual Studio Code 	- IDE used to create Terraform Projects 
			
				https://code.visualstudio.com/download
				
		
		- Open Visual Studio Code 
		
		- Install the Extension/Plugins :
		
			Terraform Extension for Visual Studio Code
		
		- Create Terraform Project :::
		
		
			- Goto File Menu - Open Folder 
		
		
			- Goto Terminal Menu and Open New Terminal 
			
				terraform --version
				
				
		
		
		
		
		Requirement :
		
			- Create AWS Resources(EC2 Instances) using Terraform :
			
				- Authentication?
				
				- Create aws access key and secret key using AWS Security Crential Page.
				
					Accesskey: sdsdf4
					
					SecretKey: qsadfs
					

    provider "aws" {
    region ="ap-south-1"
    access_key = "dfasdfFKJDHF"
    secret_key = "adsfhadkflhalkdfhaklsd"
    }


      resource "aws_instance" "example" {
         ami           = "resolve:ssm:/aws/service/ami-amazon-linux-latest/al2023-ami-kernel-default-x86_64"
         instance_type = "t3.micro"

         tags = {
          Name = "HelloWorld"
          }
      }

		- Terraform Process Workflow :::
		
			- Identify the Scope of Target Environment (AWS/Azure/GCP)
			
			- Write Terraform Scripts based on the Scope 
			
			- Perform Terraform Init --> Initialize Terraform Provider to the Terraform Project 
			
			- Perform Terraform Plan --> To Preview the Terraform Script
			
			- Perform Terraform Apply -> To apply the changes to target Infra-Structure
			
			
		- Using Terraform :::
		
			- Create/Add resources 					====> 		'+'
			
			- Destroy/Delete Resources 				====>		'-'
			
			- Update/Alter Resources 				====> 		'~'
			
			
	
		- Terraform State file- :
			
			terraform:tfstate 		
			
			
			
			terraform init 
			
			terraform plan 
			
			terraform apply
			
			terraform apply -auto-approve
			
			terraform destroy
			
			terraform destroy -auto-approve
			


Demo2: We will deploy a project with below resources
EC2 instance- security group- subnet- vpc- routetable- Internetgatewauy

- File menu
- click on open folder
- pl-tf-project2
- 
#################################
# Provider
#################################
provider "aws" {
  region = "ap-south-1"
}

#################################
# VPC
#################################
resource "aws_vpc" "main" {
  cidr_block           = "10.0.0.0/16"
  enable_dns_support   = true
  enable_dns_hostnames = true

  tags = {
    Name = "main-vpc"
  }
}

#################################
# Subnet (Public)
#################################
resource "aws_subnet" "public" {
  vpc_id                  = aws_vpc.main.id
  cidr_block              = "10.0.1.0/24"
  availability_zone       = "ap-south-1a"
  map_public_ip_on_launch = true

  tags = {
    Name = "public-subnet"
  }
}

#################################
# Internet Gateway
#################################
resource "aws_internet_gateway" "gw" {
  vpc_id = aws_vpc.main.id

  tags = {
    Name = "main-igw"
  }
}

#################################
# Route Table
#################################
resource "aws_route_table" "public_rt" {
  vpc_id = aws_vpc.main.id

  route {
    cidr_block = "0.0.0.0/0"
    gateway_id = aws_internet_gateway.gw.id
  }

  tags = {
    Name = "public-route-table"
  }
}

#################################
# Route Table Association
#################################
resource "aws_route_table_association" "public_assoc" {
  subnet_id      = aws_subnet.public.id
  route_table_id = aws_route_table.public_rt.id
}

#################################
# Security Group
#################################
resource "aws_security_group" "web_sg" {
  name        = "web-sg"
  description = "Allow SSH and HTTP"
  vpc_id      = aws_vpc.main.id

  ingress {
    description = "SSH"
    from_port   = 22
    to_port     = 22
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  ingress {
    description = "HTTP"
    from_port   = 80
    to_port     = 80
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }

  tags = {
    Name = "web-security-group"
  }
}

#################################
# EC2 Instance
#################################
resource "aws_instance" "example" {
  ami                         = "resolve:ssm:/aws/service/ami-amazon-linux-latest/al2023-ami-kernel-default-x86_64"
  instance_type               = "t2.micro"
  subnet_id                   = aws_subnet.public.id
  vpc_security_group_ids      = [aws_security_group.web_sg.id]
  associate_public_ip_address = true
  key_name                    = "aws2025-keypair1"

  tags = {
    Name = "HelloWorld"
  }
}



terraform init
terraform validate
terraform plan
terraform apply



	DevOps ::::
	
		CICD Pipeline:
		
		Scenario1 :
		
			Pipeline1 :
			
			- SCM-Checkout --> Build --> Deployed to Test Server 
			

		Scenario2 :

			Pipeline1 :
			Source_Code Repo :
			
			- SCM-Checkout --> Create New_Test_Server(Terraform) --> Configure New_Test_Server(Ansible)


			
			Pipeline2 :
			Source_Code Repo :
			- SCM-Checkout --> Build --> Deployed to New_Test_Server

			
		Scenario3 :
		
			Source_Code Repo :
			
				Application Source Code 
				
				Terraform Scripts 
				
				Ansible Playbooks 
				
				
			Pipeline1:
			
				SCM-Checkout --> Application_Build --> Create New_Test_Server(Terraform) --> Configure New_Test_Server(Ansible)
				
																												|
																												|
																												|
																						
																						  Deploy the changes to New_Test_Server
																						  
																						  
																												|
																												|
																												|
																												
																										Automated Testing 
																										
																												|
																												|
																												|
																												
																										Notify the User  
																										
																										Delete the New_Test_Server using Terraform Destroy 

																												|
																												|
																												|
																												
																											Deploy to Prod				
				
SCM Checkout
    ↓
Application Build
    ↓
Create New Test Server (Terraform)
    ↓
Configure New Test Server (Ansible)
    ↓
Deploy changes to Test Server (Ansible)
    ↓
Automated Testing
    ↓
Notify User
    ↓
Destroy Test Server (Terraform)
    ↓
Deploy to Prod (Ansible)


				
			pipeline {
    agent any

    stages {

        /* --------------------------- 1. SCM CHECKOUT --------------------------- */
        stage('SCM Checkout') {
            steps {
                echo "Checking out source code..."
                checkout scm
            }
        }

        /* --------------------------- 2. BUILD APPLICATION ---------------------- */
        stage('Application Build') {
            steps {
                echo "Building application..."
                sh """
                    mvn clean package          # Java example
                    # or: npm install && npm run build
                    # or: go build main.go
                """
            }
        }

        /* ------------------ 3. CREATE NEW TEST SERVER USING TERRAFORM ---------- */
        stage('Create New Test Server (Terraform)') {
            steps {
                sh """
                    cd infra/
                    terraform init
                    terraform apply -auto-approve \
                      -var environment=test
                """
            }
        }

        /* ------------------ 4. CONFIGURE NEW TEST SERVER (ANSIBLE) ------------ */
        stage('Configure New Test Server (Ansible)') {
            steps {
                sh """
                    ansible-playbook -i inventory/test.ini configure_server.yml
                """
            }
        }


[test]
test-server ansible_host=PUBLIC_EC2_IP ansible_user=ec2-user


---
- name: Configure New Test Server
  hosts: all
  become: true

  vars:
    app_user: ec2-user
    java_package: java-17-amazon-corretto

  tasks:

    #################################
    # UPDATE OS PACKAGES
    #################################
    - name: Update all packages to latest
      yum:
        name: "*"
        state: latest

    #################################
    # INSTALL REQUIRED PACKAGES
    #################################
    - name: Install Java, Git, Maven, and Docker
      yum:
        name:
          - "{{ java_package }}"
          - git
          - docker
          - maven
        state: present

    #################################
    # CONFIGURE DOCKER
    #################################
    - name: Start and enable Docker service
      service:
        name: docker
        state: started
        enabled: yes

    - name: Add ec2-user to Docker group
      user:
        name: "{{ app_user }}"
        groups: docker
        append: yes

    #################################
    # CONFIGURE FIREWALL (optional)
    #################################
    - name: Allow HTTP traffic through firewall
      firewalld:
        service: http
        permanent: true
        state: enabled
      ignore_errors: true

    - name: Reload firewall
      command: firewall-cmd --reload
      ignore_errors: true

    #################################
    # FINAL CONFIRMATION
    #################################
    - name: Print server configuration done
      debug:
        msg: "Server configuration complete and ready for application deployment"


        /* --------------------------- 5. DEPLOY CHANGES ------------------------- */
        stage('Deploy to New Test Server') {
            steps {
                sh """
                    ansible-playbook -i inventory/test.ini deploy_app.yml
                """
            }
        }

[test]
test-server ansible_host=PUBLIC_EC2_IP ansible_user=ec2-user


---
- name: Deploy Application to Test Server
  hosts: all
  become: true

  vars:
    app_name: demo-app
    app_user: ec2-user
    app_dir: /opt/demo-app
    jar_file: demo-app.jar

  tasks:

    #################################
    # CREATE APP DIRECTORY
    #################################
    - name: Ensure application directory exists
      file:
        path: "{{ app_dir }}"
        state: directory
        owner: "{{ app_user }}"
        group: "{{ app_user }}"
        mode: "0755"

    #################################
    # COPY APPLICATION JAR
    #################################
    - name: Copy application JAR to server
      copy:
        src: target/{{ jar_file }}   # Assumes Jenkins build outputs JAR to target/
        dest: "{{ app_dir }}/{{ jar_file }}"
        owner: "{{ app_user }}"
        group: "{{ app_user }}"
        mode: "0755"
      notify: Restart application service

    #################################
    # CREATE SYSTEMD SERVICE
    #################################
    - name: Create systemd service for application
      copy:
        dest: "/etc/systemd/system/{{ app_name }}.service"
        content: |
          [Unit]
          Description=Demo Java Application
          After=network.target

          [Service]
          User={{ app_user }}
          ExecStart=/usr/bin/java -jar {{ app_dir }}/{{ jar_file }}
          SuccessExitStatus=143
          Restart=always
          RestartSec=10

          [Install]
          WantedBy=multi-user.target
      notify: Restart application service

    - name: Reload systemd daemon
      command: systemctl daemon-reexec

    #################################
    # START AND ENABLE SERVICE
    #################################
    - name: Enable and start application service
      service:
        name: "{{ app_name }}"
        state: started
        enabled: yes

  #################################
  # HANDLER: RESTART SERVICE
  #################################
  handlers:
    - name: Restart application service
      service:
        name: "{{ app_name }}"
        state: restarted


        /* --------------------------- 6. AUTOMATED TESTING ---------------------- */
        stage('Automated Testing') {
            steps {
                sh """
                    pytest tests/automation/        # Python tests
                    # or: mvn test
                    # or: npm test
                """
            }
        }

        /* --------------------------- 7. NOTIFY USER ---------------------------- */
        stage('Notify User') {
            steps {
                sh """
                    echo "Sending notification..."
                """
                // Example: Slack notification
                // slackSend(channel: '#devops', message: "Tests complete on test server!")
            }
        }

        /* ---------------------- 8. DESTROY TEST SERVER (Terraform) ------------- */
        stage('Delete New Test Server (Terraform Destroy)') {
            steps {
                sh """
                    cd infra/
                    terraform destroy -auto-approve \
                      -var environment=test
                """
            }
        }

        /* --------------------------- 9. DEPLOY TO PROD ------------------------- */
        stage('Deploy to Prod') {
            steps {
                sh """
                    ansible-playbook -i inventory/prod.ini deploy_app.yml
                """
            }
        }
    }
}

[prod]
prod-server ansible_host=PROD_EC2_PUBLIC_IP ansible_user=ec2-user

---
- name: Deploy Application to Production Server
  hosts: prod
  become: true

  vars:
    app_name: demo-app
    app_user: ec2-user
    app_dir: /opt/demo-app
    jar_file: demo-app.jar

  tasks:

    #################################
    # CREATE APPLICATION DIRECTORY
    #################################
    - name: Ensure application directory exists
      file:
        path: "{{ app_dir }}"
        state: directory
        owner: "{{ app_user }}"
        group: "{{ app_user }}"
        mode: "0755"

    #################################
    # COPY APPLICATION JAR
    #################################
    - name: Copy application JAR to production server
      copy:
        src: target/{{ jar_file }}    # Jenkins workspace output
        dest: "{{ app_dir }}/{{ jar_file }}"
        owner: "{{ app_user }}"
        group: "{{ app_user }}"
        mode: "0755"
      notify: Restart application service

    #################################
    # CREATE SYSTEMD SERVICE
    #################################
    - name: Create systemd service for production app
      copy:
        dest: "/etc/systemd/system/{{ app_name }}.service"
        content: |
          [Unit]
          Description=Demo Java Application
          After=network.target

          [Service]
          User={{ app_user }}
          ExecStart=/usr/bin/java -jar {{ app_dir }}/{{ jar_file }}
          SuccessExitStatus=143
          Restart=always
          RestartSec=10

          [Install]
          WantedBy=multi-user.target
      notify: Restart application service

    - name: Reload systemd daemon
      command: systemctl daemon-reexec

    #################################
    # ENABLE AND START SERVICE
    #################################
    - name: Enable and start application service
      service:
        name: "{{ app_name }}"
        state: started
        enabled: yes

  #################################
  # HANDLER: RESTART SERVICE
  #################################
  handlers:
    - name: Restart application service
      service:
        name: "{{ app_name }}"
        state: restarted


infra/
├── provider.tf
├── main.tf
├── variables.tf
├── outputs.tf

1️⃣ provider.tf

provider "aws" {
  region     = "ap-south-1"
  access_key = "YOUR_AWS_ACCESS_KEY"     # or use environment variables
  secret_key = "YOUR_AWS_SECRET_KEY"
}

2️⃣ variables.tf

variable "environment" {
  description = "Environment name (test/prod)"
  default     = "test"
}

variable "vpc_cidr" {
  default = "10.0.0.0/16"
}

variable "subnet_cidr" {
  default = "10.0.1.0/24"
}

variable "instance_type" {
  default = "t2.micro"
}

variable "key_name" {
  description = "Name of the EC2 key pair"
  default     = "aws2025-keypair1"
}

3️⃣ main.tf

#######################################
# VPC
#######################################
resource "aws_vpc" "main" {
  cidr_block       = var.vpc_cidr
  instance_tenancy = "default"

  tags = {
    Name = "${var.environment}-vpc"
  }
}

#######################################
# Subnet
#######################################
resource "aws_subnet" "main" {
  vpc_id                  = aws_vpc.main.id
  cidr_block              = var.subnet_cidr
  map_public_ip_on_launch = true

  tags = {
    Name = "${var.environment}-subnet"
  }
}

#######################################
# Internet Gateway
#######################################
resource "aws_internet_gateway" "gw" {
  vpc_id = aws_vpc.main.id

  tags = {
    Name = "${var.environment}-igw"
  }
}

#######################################
# Route Table
#######################################
resource "aws_route_table" "main" {
  vpc_id = aws_vpc.main.id

  route {
    cidr_block = "0.0.0.0/0"
    gateway_id = aws_internet_gateway.gw.id
  }

  tags = {
    Name = "${var.environment}-rt"
  }
}

#######################################
# Route Table Association
#######################################
resource "aws_route_table_association" "main" {
  subnet_id      = aws_subnet.main.id
  route_table_id = aws_route_table.main.id
}

#######################################
# Security Group
#######################################
resource "aws_security_group" "sg" {
  name        = "${var.environment}-sg"
  description = "Allow SSH and HTTP"
  vpc_id      = aws_vpc.main.id

  ingress {
    from_port   = 22
    to_port     = 22
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  ingress {
    from_port   = 80
    to_port     = 80
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }

  tags = {
    Name = "${var.environment}-sg"
  }
}

#######################################
# Key Pair
#######################################
resource "aws_key_pair" "key" {
  key_name   = var.key_name
  public_key = file("~/.ssh/id_rsa.pub")   # Replace with your public key
}

#######################################
# EC2 Instance
#######################################
resource "aws_instance" "app" {
  ami                         = "resolve:ssm:/aws/service/ami-amazon-linux-latest/al2023-ami-kernel-default-x86_64"
  instance_type               = var.instance_type
  subnet_id                   = aws_subnet.main.id
  vpc_security_group_ids      = [aws_security_group.sg.id]
  associate_public_ip_address = true
  key_name                    = aws_key_pair.key.key_name

  tags = {
    Name = "${var.environment}-app-server"
  }
}


4️⃣ outputs.tf

output "instance_public_ip" {
  description = "Public IP of the EC2 instance"
  value       = aws_instance.app.public_ip
}

output "instance_private_ip" {
  description = "Private IP of the EC2 instance"
  value       = aws_instance.app.private_ip
}

output "vpc_id" {
  value = aws_vpc.main.id
}

output "subnet_id" {
  value = aws_subnet.main.id
}


✅ How It Works

VPC & Subnet → Creates a network for the EC2 instance.

Internet Gateway & Route Table → Makes subnet public and routable.

Security Group → Allows SSH (22) and HTTP (80).

Key Pair → Enables secure SSH login.

EC2 Instance → Launches t2.micro Amazon Linux 2023 instance.

Outputs → Public IP can be used in dynamic Ansible inventory.


Next :::

	Continuous Monitoring using Prometheus/Grafana :::
